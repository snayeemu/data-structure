Doubly Linked List: একটি দুমুখি রাস্তার গল্প

পর্ব ১: তত্ত্ব (Theory)  
কোনো একসময়, একটি দেশ ছিল, নাম ডেটা স্ট্রাকচার। সেখানে বসবাস করত লাজুক তবে কাজে পারদর্শী একটি ডেটা স্ট্রাকচার, নাম ডাবলি লিঙ্কড লিস্ট। এখন, যদি তুমি তার আত্মীয়, সিঙ্গলি লিঙ্কড লিস্ট সম্পর্কে কিছু শুনে থাকো, তাহলে জানো এটি অনেকটা একমুখী রাস্তার মতো — প্রতিটি নোড (Node) শুধুমাত্র তার পরের প্রতিবেশীর কথা জানে। এটি কাজ করে, তবে কিছুটা সীমাবদ্ধ।

কিন্তু ডাবলি লিঙ্কড লিস্ট আলাদা। এটি দুই দিকের রাস্তার মতো। কল্পনা করো একটি গ্রাম যেখানে প্রতিটি বাড়ি (নোড) একটি রাস্তা দিয়ে পরের বাড়ির সাথে সংযুক্ত। কিন্তু এখানে আরও একটি বিষয় আছে: প্রতিটি বাড়ির শুধু পরের বাড়িতে যাওয়ার জন্য একটি রাস্তা নয়, পূর্ববর্তী বাড়িতেও যাওয়ার জন্য একটি রাস্তা আছে। তাই যদি তুমি ভুল বাড়িতে চলে যাও, তবে পুরো গ্রাম না ঘুরে, সহজেই পিছনের দিকে ফিরে যেতে পারবে। 

টেকনিক্যাল ভাষায় বলতে গেলে, একটি ডাবলি লিঙ্কড লিস্ট হলো নোডের সংগ্রহ (Collection of Nodes), যেখানে প্রতিটি নোডে তিনটি জিনিস থাকে:
1. ডাটা (data): প্রতিটি নোডের ভেতরে থাকা তথ্য (value)।  
2. পরবর্তী নোডের দিকে নির্দেশ করা একটি পয়েন্টার (next): সেই রাস্তা যা পরবর্তী বাড়ির দিকে নিয়ে যায়।  
3. পূর্ববর্তী নোডের দিকে নির্দেশ করা একটি পয়েন্টার (previous): সেই রাস্তা যা পূর্ববর্তী বাড়ির দিকে ফিরে যায়।  

এই দুই দিকের সংযোগ এটিকে অত্যন্ত কার্যকরী বানিয়েছে, বিশেষত যখন লিস্টের উভয় দিকে ট্রাভার্স করার প্রয়োজন হয় বা লিস্টটি উল্টাতে (reverse) হয়।

---

পর্ব ২: উদাহরণ  
কল্পনা করো: তুমি একটি বিশাল লাইব্রেরিতে আছো, প্রতিটি শেলফ বইয়ে (নোড) ঠাসা, এবং তুমি কোডিং সম্পর্কিত একটি নির্দিষ্ট বই খুঁজছো। কিন্তু শেলফগুলো এমনভাবে সাজানো যে তুমি শুধুমাত্র একদিকেই হাঁটতে পারো। যদি তুমি তোমার বই মিস করো, তাহলে শুরুতে ফিরে যেতে হবে এবং আবার খুঁজতে হবে। বিরক্তিকর, তাই না? 

এখন, কল্পনা করো লাইব্রেরিতে একটি পরিবর্তন এসেছে। প্রতিটি শেলফে এখন সামনে বা পেছনে দুই দিকেই যেতে পারো। এভাবে, যদি তুমি তোমার বই মিস করো, তবে আবার শুরুতে ফিরে না গিয়ে পিছনে যেতে পারো। এটাই ডাবলি লিঙ্কড লিস্টের কাজ! এটি তোমাকে সামনে বা পেছনে যাওয়ার সুযোগ দেয়, সময় এবং পরিশ্রম বাঁচায়। 

---

পর্ব ৩: কোড  
এখন, আসো কোডের জগতে ঢুকে পড়ি, যেখানে জাদু ঘটে। এখানে সি++ (C++) ল্যাংগুয়েজে ডাবলি লিঙ্কড লিস্টের ইমপ্লিমেন্টেশন রয়েছে:

```````````````
#include <bits/stdc++.h>
using namespace std;

class Node // Node কে আমরা বাড়ি মনে করি
{
public:
    int value;         // বাড়িতে থাকা সম্পদের পরিমাণ
    Node *prev = NULL; // এটি আমাদের আগের বাড়িতে ফিরে যাওয়ার রাস্তা
    Node *next = NULL; // এটি আমাদের পরের বাড়িতে যাওয়ার রাস্তা
};

class linkedList
{
public:
    Node *head, *tail; // head = গ্রামের প্রথম বাড়ির ঠিকানা, tail = গ্রামের শেষ বাড়ি
    int size;          // বর্তমানে গ্রামে কতটি বাড়ি আছে

    linkedList() // গ্রামে কোনো বাড়ি বানানোর আগে গ্রামের অবস্থা কেমন ছিলো
    {
        this->head = NULL; // কোনো বাড়ি নেই, তাই প্রথম বাড়ির ঠিকানাও নেই
        this->tail = NULL; // কোনো বাড়ি নেই, তাই শেষ বাড়ির ঠিকানাও নেই
        this->size = 0;    // গ্রামে এখন বাড়ির সংখ্যা ০ টি
    }

    void push(int value) // নতুন বাড়ি গ্রামের শেষ প্রান্তে তৈরি করা হলে যা হবে
    {
        Node *temp = new Node; // একটি বাড়ি তৈরি করা হলো
        temp->value = value;   // বাড়িতে সম্পদ রাখা হলো

        if (head == NULL) // যদি গ্রামে কোনো বাড়ি না থাকে
        {
            head = temp; // তাহলে তৈরি করা নতুন বাড়িটিই হচ্ছে প্রথম বাড়ি
            tail = temp; // আবার তৈরি করা নতুন বাড়িটিই হচ্ছে শেষ বাড়ি
        }
        else // যদি গ্রামে কোনো বাড়ি থাকে
        {
            temp->prev = tail; // তাহলে বর্তমান বাড়ির prev নামক রাস্তা দিয়ে, আগে শেষে যেই বাড়িটি ছিল সেই বাড়িতে যাওয়া যাবে
            tail->next = temp; // আগে শেষে যেই বাড়িটি ছিল সেটার next নামক রাস্তা দিয়ে মাত্র তৈরি বাড়িতে যাওয়া যাবে
            tail = temp;       // মাত্র তৈরি বাড়িটিই হচ্ছে বর্তমানে গ্রামের শেষ বাড়ি
        }
        size++; // নতুন একটি বাড়ি তৈরি হওয়ায় বাড়ির সংখ্যা ১ বেড়েছে।
    }

    void print() // গ্রামের ম্যাপ
    {
        Node *temp = head;   // প্রথম বাড়ির ঠিকানা
        while (temp != NULL) // যতক্ষণ না শেষ বাড়ি পর্যন্ত পৌঁছাচ্ছি
        {
            cout << temp->value << " "; // বাড়িটি আঁকা হচ্ছে
            temp = temp->next;          // next রাস্তা দিয়ে পরের বাড়িতে যাওয়া হচ্ছে
        }
        cout << endl;
    }

    void insert(int value, int position) // যে কোনো একটি জায়গায় একটি বাড়ি তৈরি করতে
    {
        Node *previous = head; // প্রথম বাড়ির ঠিকানা
        Node *current = NULL;  // বাড়ির ঠিকানা রাখার জায়গা

        if (position == 0) // যদি গ্রামের শুরুতে তৈরি করতে হয়
        {
            this->insertAtHead(value); // insertAtHead এ থাকা নির্দেশনা অনুসরণ করতে হবে
            return;
        }

        if (position > size) // যদি বাড়িটির জন্য বরাদ্দ জায়গা গ্রামের মধ্যে না হয়
        {
            cout << "Invalid" << endl; // বাড়িটি গ্রামের বাইরে হওয়ায় কোনো পরিবর্তন হবে না
            return;
        }

        for (int i = 0; i < position - 1; i++) // বর্তমান বাড়ির আগের বাড়ি না পাওয়া পর্যন্ত যেতে থাক
        {
            previous = previous->next; // বর্তমান বাড়ির next নামক রাস্তা দিয়ে পরের বাড়ি যাও
            if (previous == NULL)      // যেতে যেতে যদি গ্রামের শেষ প্রান্তে চলে আসো
            {
                cout << "Invalid" << endl; // তাহলে বাড়িটি এই গ্রামের মধ্যে না
                return;
            }
        }

        if (previous == tail) // যদি বর্তমান বাড়িটি গ্রামের শেষ বাড়ি হয়
        {
            push(value); // তাহলে push এ থাকা নির্দেশনা অনুসরণ করো
            return;
        }

        // বাড়িটি মাঝামাঝি কোথাও হলে
        current = previous->next; // বর্তমান বাড়ির পরের বাড়ির ঠিকানা

        Node *newNode = new Node; // নতুন বাড়ি তৈরি হলো
        newNode->value = value;   // নতুন বাড়িতে সম্পদ রাখা হলো
        previous->next = newNode; // আগের বাড়ির next রাস্তাটা নতুন বাড়ির সাথে যুক্ত হলো
        current->prev = newNode;  // পরের বাড়ির prev নামক রাস্তাটা নতুন বাড়ির সাথে যুক্ত হলো
        newNode->next = current;  // নতুন বাড়ি থেকে পরের বাড়িতে যাওয়ার রাস্তা
        newNode->prev = previous; // নতুন বাড়ি থেকে আগের বাড়িতে যাওয়ার রাস্তা

        size++; // নতুন একটি বাড়ি তৈরি হওয়ায় বাড়ির সংখ্যা ১ বেড়েছে।
    }

    void insertAtHead(int value) // গ্রামের শুরুতে বাড়ি তৈরি করতে হলে
    {
        Node *newNode = new Node; // নতুন বাড়ি তৈরি করা হলো
        newNode->value = value;   // নতুন বাড়িতে সম্পদ রাখা হলো
        newNode->next = head;     // নতুন বাড়ি থেকে আগের head এ থাকা লোকেশনের দিকে একটি রাস্তা তৈরি করা হলো

        if (head == NULL) // গ্রামে যদি আগে থেকে কোনো বাড়ি না থাকে
        {
            head = newNode; // তাহলে নতুন বাড়িটি গ্রামের প্রথম বাড়ি
            tail = newNode; // তাহলে নতুন বাড়িটি গ্রামের শেষ বাড়ি
            size++;         // নতুন একটি বাড়ি তৈরি হওয়ায় বাড়ির সংখ্যা ১ বেড়েছে।
            return;
        }

        // অথবা
        head->prev = newNode; // head এ থাকা ঠিকানার বাড়ি থেকে নতুন বাড়ির দিকে prev নামক রাস্তা তৈরি করতে হবে
        newNode->next = head; // head এ থাকা ঠিকানার দিকে next নামক রাস্তা তৈরি করতে হবে
        head = newNode;       // নতুন বাড়িটিই গ্রামের প্রথম বাড়ি

        size++; // নতুন একটি বাড়ি তৈরি হওয়ায়

 বাড়ির সংখ্যা ১ বেড়েছে।
    }
};

int main()
{
    linkedList ob; // গ্রামের মানচিত্র (মাস্টার প্ল্যান)
    ob.push(1);    // একটি নতুন বাড়ি তৈরি হলো
    ob.push(2);    // একটি নতুন বাড়ি তৈরি হলো
    ob.push(3);    // একটি নতুন বাড়ি তৈরি হলো
    ob.insert(99, 3);
    ob.insertAtHead(13);
    ob.print(); // গ্রামের ম্যাপ আঁকা হচ্ছে

    return 0;
}
```````````````

